// Checker for basic communication-style tasks to be used by HSIN evaluator.
//
// This task type assumes two actors exchanging a single message. The utility of
// this checker program is two-fold, as explained in the following (typical)
// sequence of events:
//
//   1) `./contestant_sol < off_in > actor_1_out`
//      The solution is ran using the official test case file as input.
//      The input file specifies that the contestant's program should take
//      the role of the first actor.
//   2) `./checker actor1 off_in off_config actor_1_out actor_2_in`
//      The checker validates the output from step 1) and generates the input
//      file for the second invocation of contestant's solution. If validation
//      fails, the checker outputs 0, ending the evaluation with WA verdict.
//   3) `./contestant_sol < actor_2_in > actor_2_out`
//      The solution is ran using the actor_2_in file generated by the first
//      checker invocation. That file specifies that the contestant's program
//      should take the role of the second actor
//   4) `./checker actor2 off_in off_config actor_1_out actor_2_in actor_2_out`
//      The checker validates the output from step 3) and judges the correctness
//      of the solution with stdout having standard semantics.
//
// This should *not* be used for CMS!
//
// Usage:
//     [checker] actor1 [official_input] [official_config] [actor_1_output]
//         [actor_2_input]
//
//     [checker] actor2 [official_input] [official_config] [actor_1_output]
//         [actor_2_input] [actor_2_output]
//
// Output (stdout):
//     Score.
//     Textual description (optional).
//
// Score should be output as an integer (0 or 1), or a real (between 0.0 and
// 1.0) or a fraction (between `0/1` and `1/1`, you don't have to
// simplify/reduce the fraction).

#include <algorithm>
#include <cassert>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)
#define REP(i, n) FOR(i, 0, n)
#define TRACE(x) cout << #x << " = " << x << endl
#define _ << " _ " <<

typedef long long llint;

// Use one of the following functions to output the points to the contestant.
// The first accepts a double and outputs it.
// The second accepts a fraction and outputs it.

void finish(double score) {
  cout << score << endl;
  exit(0);
}

void finish(llint points_awarded, llint points_max) {
  cout << points_awarded << "/" << points_max << endl;
  exit(0);
}

// Helper functions.

vector<string> split(const string &a, const string &delim) {
  vector<string> ans;
  int ptr = 0;
  for (size_t f_pos; (f_pos = a.find(delim, ptr)) != string::npos;) {
    ans.push_back(a.substr(ptr, f_pos - ptr));
    ptr = f_pos + delim.size();
  }
  ans.push_back(a.substr(ptr));
  return ans;
}

vector<int> gen_c(const vector<int> &a, const vector<int> &b) {
  vector<int> ret;
  map<int, int> cnt;

  for (int ai : a) cnt[ai]++;
  for (int bi : b) cnt[bi]++;

  for (auto &p : cnt)
    ret.emplace_back(p.second);

  sort(ret.begin(), ret.end());

  return ret;
}

/**
 * The main checking function for actor 1.
 * @param fin   official input (input stream)
 * @param fconf official config (input stream)
 * @param a1out actor 1 output (input stream)
 * @param a2in  actor 2 input (output stream)
 */
void check_a1(ifstream &fin, ifstream &fconf, ifstream &a1out, ofstream &a2in) {
  const int MAXA = 1e9;

  // Parse official input file
  int L_in, Q_in;

  if (!(fin >> L_in)) finish(0);
  if (!(fin >> Q_in)) finish(0);

  string in_actors = "";
  vector<int> in_nums;
  for (int i = 0; i < Q_in; ++i) {
    string in_actor;
    int num;
    if (!(fin >> in_actor)) finish(0);
    if (!(fin >> num)) finish(0);
    if (in_actor[0] != 'a' && in_actor[0] != 'b') finish(0);
    in_actors.push_back(in_actor[0]);
    in_nums.push_back(num);
  }

  // Validate and store actor 1 output.
  vector<vector<int>> a1_arrays;
  for (int i = 0; i < Q_in; ++i) {
    int l;
    if (!(a1out >> l)) finish(0);
    if (l < 0 || l > L_in) finish(0);

    vector<int> curr_array;
      for (int j = 0; j < l; ++j) {
      int x;
      if (!(a1out >> x)) finish(0);
      if (x < 0 || x > MAXA) finish(0);
      curr_array.emplace_back(x);
    }

    a1_arrays.emplace_back(curr_array);
  }
  string garbage;
  if (a1out >> garbage) finish(0);


  // Generate a2in based on config file and a1out
  int Q_conf;
  if (!(fconf >> Q_conf)) finish(0);

  if (!(a2in << L_in << "\n" << Q_conf << "\n")) finish(0);
  for (int i = 0; i < Q_conf; ++i) {
    int a, b;
    if (!(fconf >> a)) finish(0);
    if (!(fconf >> b)) finish(0);

    if (a <= 0 || a > Q_in) finish(0);
    if (b <= 0 || b > Q_in) finish(0);
    --a; --b;

    if (in_actors[a] == in_actors[b]) finish(0);
    if (in_nums[a] == in_nums[b]) finish(0);

    auto c = gen_c(a1_arrays[a], a1_arrays[b]);

    if (!(a2in << "cecilija")) finish(0);
    if (!(a2in << " " << (int)c.size())) finish(0);
    for (int ci : c)
      if (!(a2in << " " << ci)) finish(0);
    if (!(a2in << "\n")) finish(0);
  }

  a2in.flush();
  finish(1);
  // The function MUST terminate before this line via finish()!
}

/**
 * The main checking function for actor 2.
 * @param fin   official input (input stream)
 * @param fconf official config (input stream)
 * @param a1out actor 1 output (input stream)
 * @param a2in  actor 2 input (input stream)
 * @param a2out actor 2 output (input stream)
 */
void check_a2(ifstream &fin, ifstream &fconf, ifstream &a1out, ifstream &a2in,
              ifstream &a2out) {
  // Parse official input file for actor 1
  int L_in, Q_in;

  if (!(fin >> L_in)) finish(0);
  if (!(fin >> Q_in)) finish(0);

  string in_actors = "";
  vector<int> in_nums;
  for (int i = 0; i < Q_in; ++i) {
    string in_actor;
    int num;
    if (!(fin >> in_actor)) finish(0);
    if (!(fin >> num)) finish(0);
    if (in_actor[0] != 'a' && in_actor[0] != 'b') finish(0);
    in_actors.push_back(in_actor[0]);
    in_nums.push_back(num);
  }

  // Parse config file and deterine correct solutions
  string correct = "";
  int Q_conf;
  if (!(fconf >> Q_conf)) finish(0);

  for (int i = 0; i < Q_conf; ++i) {
    int a, b;
    if (!(fconf >> a)) finish(0);
    if (!(fconf >> b)) finish(0);

    if (a <= 0 || a > Q_in) finish(0);
    if (b <= 0 || b > Q_in) finish(0);
    --a; --b;

    if (in_actors[a] == in_actors[b]) finish(0);
    if (in_nums[a] == in_nums[b]) finish(0);

    if (in_actors[a] != 'a') swap(a, b);

    if (in_nums[a] > in_nums[b])
      correct.push_back('A');
    else
      correct.push_back('B');
  }

  // Evaluate actor 2 output
  for (int i = 0; i < Q_conf; ++i) {
    string out_i;
    if (!(a2out >> out_i)) finish(0);
    if ((int) out_i.size() != 1) finish(0);
    if (out_i[0] != correct[i]) finish(0);
  }
  string garbage;
  if (a2out >> garbage) finish(0);

  finish(1);
  // The function MUST terminate before this line via finish()!
}

int main(int argc, char *argv[]) {
  assert(argc >= 6);

  ifstream fin(argv[2]);
  ifstream fconf(argv[3]);
  ifstream a1out(argv[4]);

  assert(!fin.fail() && !fconf.fail() && !a1out.fail());

  if (strcmp(argv[1], "actor1") == 0) {
    ofstream a2in(argv[5]);
    assert(!a2in.fail());
    check_a1(fin, fconf, a1out, a2in);
  }

  if (strcmp(argv[1], "actor2") == 0) {
    ifstream a2in(argv[5]);
    ifstream a2out(argv[6]);
    assert(!a2in.fail() && !a2out.fail());
    check_a2(fin, fconf, a1out, a2in, a2out);
  }

  assert(false);

  return 0;
}
