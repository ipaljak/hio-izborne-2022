\subsection*{Zadatak Vinjete}
\textsf{Pripremili: Dominik Fistrić i Ivan Paljak}\\
\textsf{Potrebno znanje: DFS obilazak stabla, tournament stablo}

Za početak ukorijenimo stablo u čvoru 1. Lako vidimo da je skup potrebnih vinjeta za putovanje do nekog čvora nadskup potrebnih vinjeta za putovanje do roditelja tog čvora. Time dolazimo na ideju da se od čvora 1 spuštamo prema ostalim čvorovima DFS obilaskom te potrebne vinjete za određeni čvor računamo samo preko potrebnih vinjeta roditelja te vinjeta potrebnih za autocestu između čvora i njegovog roditelja. Taj pristup vodi do pravog rješenja, no ovisno o načinu pamćenja vinjeta nekog čvora te spajanja istih s potrebnim vinjetama na autocesti dobivamo rješenja za pojedine podzadatke.

U prvom podzadatku vinjete nekog čvora pamtimo kao niz nula i jedinica gdje jedinica predstavlja da moramo kupiti tu vinjetu. Prolaskom po bridu iteriramo od $a_i$ do $b_i$ te u nizu stavljamo jedinicu na te pozicije. Složenost ovog pristupa je $O(N * M)$ što je dovoljno dobro za prvi podzadatak.

U drugom podzadatku umjesto niza ćemo za intervale vinjeta pamtiti samo početak i kraj svakog intervala. Kada prolazimo po bridu samo ubacujemo novi početak i kraj intervala, a da bi izračunali koliko vinjeta je potrebno u trenutnom čvoru koristimo se jednostavnim sweep-line algoritmom na sortiranim početcima i krajevima. Za spremanje početaka i krajeva intervala možemo koristiti sortiranu strukturu poput Multiset-a te je složenost tada $O(N^2 + N * log(n))$.

U trećem podzadatku možemo pristupiti slično kao u prvom, no sada umjesto niza brojeva koristimo niz bitova (Bitset). Postupak je isti kao u prvom podzadatku, no kako koristimo Bitset memorijska i vremenska složenost će biti $O(\frac{N * M}{64})$ što je dovoljno za taj podzadataka.

U četvrtom i petom podzadatku ćemo za pamćenje vinjeta koristiti tournament stablo. Operacije koje moramo podržavati su: suma svih jedinica u stablu te postavi sve čvorove u intervalu na jedinice. Dodatni implementacijski detalj koji treba promotriti je vraćanje "unazad", odnosno kada DFS završi s podstablom te se vraća nazad u roditelja (kako bi se eventualno pozvao za neko drugo dijete) potrebno je vratiti se u stanje u kojemu je roditelj originalno bio odnosno povratiti stanje u tournamentu prije prolaska po bridu. Na to je potrebno paziti i u prijašnjim podzadacima, no tamo je relativno lagano vratiti stanje na prijašnje u dobroj složenosti pa prije nije spominjano. Kako bi riješili taj problem možemo koristiti perzistentni tournament koji nam dopušta vraćanja u prošla stanja (https://wiki.xfer.hr/povijesna/) ili je moguće pametnije pamtiti stvari u običnom tournamentu kako bi bilo lakše vratiti se unazad (ostavljamo čitatelju za vježbu). Sama složenost algoritma će biti $O(N * log(N))$ što je dovoljno dobro za oba podzadatka, no treba pripaziti na memorijsku složenost. Ukoliko je tournament implementiran klasično kao niz memorijska složenost će biti $O(M)$ što je dovoljno za četvrti podzadatak, no previše za zadnji. Potrebno je implementirati takozvani sparse tournament (umjesto niza tournament je implementiran preko čvorova s pointerima na djecu) koji zauzima $O(N * log(N))$ memorije što je dovoljno dobro za sve podzadatake.
